ğŸš€ REPLIT PROMPT â€” Fully Functional Shodh-a-Code Platform Prototype (Spring Boot + Next.js + Docker)

Paste this entire block in Replitâ€™s prompt box:

Prompt for Replit:

I want you to create a fully functional prototype of the â€œShodh-a-Codeâ€ Contest Platform within Replit free limits.
Please build this project with the following requirements:

ğŸ§© OVERVIEW

Build a basic but working end-to-end system that lets users:

Join a contest with a username and contest ID.

View problems for that contest.

Submit code for a problem.

Run submissions securely in Docker (limited to small Java programs).

See results live (â€œPendingâ€, â€œRunningâ€, â€œAcceptedâ€, â€œWrong Answerâ€).

View a live leaderboard (auto-refresh every few seconds).

No fancy design â€” just a functional UI and working backend.

âš™ï¸ TECH STACK

Backend (Folder: /backend)

Spring Boot (Java 17)

RESTful API

In-memory DB using H2 (to stay Replit-compatible)

Docker integration using ProcessBuilder (to run user code)

Expose the following endpoints:

GET /api/contests/{contestId} â€” Get contest + problem list

POST /api/submissions â€” Submit code

GET /api/submissions/{submissionId} â€” Poll submission status

GET /api/contests/{contestId}/leaderboard â€” Get current leaderboard

Use a pre-seeded contest with 2â€“3 problems and sample input/output test cases stored in JSON.

Judging Engine

On submission:

Save code to a temp file (Main.java)

Run a Docker command to execute code (limit CPU/time)

Compare stdout with expected output

Update submission status (Accepted / Wrong Answer / Error)

Use minimal Docker image: openjdk:17-alpine

Frontend (Folder: /frontend)

Next.js + Tailwind CSS

Pages:

/join â€” Enter Contest ID + Username

/contest/[id] â€” Show problem list, code editor (simple textarea), submit button

Leaderboard (poll backend every 15â€“30s)

Submission status panel (poll every 2â€“3s)

State Management: React hooks only (no Redux, keep it simple)

Use fetch for all API calls.

Containerization

A top-level docker-compose.yml that:

Starts both backend and frontend

Mounts Docker socket so backend can spawn judge containers

ğŸ“¦ PROJECT STRUCTURE
shodh-a-code/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ pom.xml
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md

ğŸ§  BACKEND HINTS

Entities (simplified):

User { id, username }

Contest { id, name, problems }

Problem { id, title, description, input, expectedOutput }

Submission { id, userId, problemId, code, status, result }

Use H2 + data.sql to prepopulate sample data.

ğŸ”¥ FRONTEND HINTS

Keep UI minimal:

<textarea> for code input

<button> to submit

<div> for showing problem and leaderboard

Use setInterval for polling endpoints.

ğŸ³ DOCKER DETAILS

backend/Dockerfile

FROM openjdk:17-jdk-slim
WORKDIR /app
COPY target/backend.jar backend.jar
ENTRYPOINT ["java", "-jar", "backend.jar"]


frontend/Dockerfile

FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install
RUN npm run build
CMD ["npm", "start"]


docker-compose.yml

version: "3.8"
services:
  backend:
    build: ./backend
    ports:
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend

ğŸ§¾ README.md REQUIREMENTS

At the top-level, include a README.md with:

Setup instructions (e.g., docker-compose up --build)

API documentation (example JSON request/response)

Short explanation of:

Backend architecture

Frontend state flow

Docker orchestration choices

ğŸ§ª TESTING

Preload one contest in data.sql:

Contest: â€œSample Contestâ€

Problems:

â€œAdd Two Numbersâ€

Input: 2 3

Expected: 5

â€œSquare a Numberâ€

Input: 4

Expected: 16

A user submits Java code like:

import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt(), b = sc.nextInt();
    System.out.println(a+b);
  }
}


The backend runs it in Docker, compares output, and updates the result.

ğŸ•’ GOAL

By the end:
âœ… You can open frontend â†’ join contest â†’ solve â†’ submit â†’ see results â†’ see leaderboard.
âœ… All data lives in-memory (H2).
âœ… Code runs inside Docker, safely and automatically.
âœ… The app runs completely within Replit (no external DBs).

âš¡ Final note for Replit

Please generate:

A working Spring Boot backend (/backend)

A working Next.js frontend (/frontend)

Docker setup (docker-compose.yml)

Sample seeded data

Clean README.md with setup steps.

Keep all code lightweight and minimal, but fully working end-to-end.